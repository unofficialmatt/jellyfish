/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  USEFUL MIXINS AND FUNCTIONS
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

@import 'linear-channel-values';

// Convert px to em
@function em($pixels) {
    @return #{$pixels/16px}em;
}

// Get a value from deep inside a map. Arguments:
// $map - name of map
// $keys - name of keys to retrieve. This can work with an infinitely nested map
@function map-deep-get($map, $keys...) {
  @each $key in $keys {
    $map: map-get($map, $key);
    @if not $map {
      //@warn "`#{$key}` does not exist in the queried key."; // Redacted as this is not super useful, because we only have one key value and not the parent key
    }
  }
  @return $map;
}

// Returns a given number divided by 2
@function h($num) {
  @return $num/2;
}

// Returns the negative value of a given number
@function n($num) {
  @return -$num;
}

// Returns the negative and halved value of a given number
@function nh($num) {
  @return n(h($num));
}
@function hn($num) {
  @return n(h($num));
}

// Media queries check the breakpoint map to see if a given string exists, else they convert a given pixel value to em.
@mixin above($min) {
    $bp-min: $min;
    @if map-has-key($breakpoints, $min) {
        $bp-min: map-deep-get($breakpoints, $min, 'breakpoint');
    }
    @else if (str-index(#{$min}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$min}` does not exist in the breakpoint map. Compile stopping.";
    }
    @media (min-width: em($bp-min)) {
        @content;
    }
}
@mixin between($min, $max) {
    $bp-min: $min;
    @if map-has-key($breakpoints, $min) {
        $bp-min: map-deep-get($breakpoints, $min, 'breakpoint');
    }
    @else if (str-index(#{$min}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$min}` does not exist in the breakpoint map. Compile stopping.";
    }
    $bp-max: $max;
    @if map-has-key($breakpoints, $max) {
        $bp-max: map-deep-get($breakpoints, $max, 'breakpoint');
    }
    @else if (str-index(#{$max}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$max}` does not exist in the breakpoint map. Compile stopping.";
    }
    @media (min-width: em($bp-min)) and (max-width: em($bp-max - 1px)) {
        @content;
    }
}
@mixin below($max) {
    $bp-max: $max;
    @if map-has-key($breakpoints, $max) {
        $bp-max: map-deep-get($breakpoints, $max, 'breakpoint');
    }
    @else if (str-index(#{$max}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$max}` does not exist in the breakpoint map. Compile stopping.";
    }
    @media (max-width: em($bp-max - 1px)) {
        @content;
    }
}

@mixin smooth($properties...) { // Global transition
    $result: (); // Create empty variable
    @each $property in $properties {
        // Loop through each argument and append to result variable
        $result: append($result, #{$property} $global-transition, comma);
    }
    transition: $result;
}

// Apply consistent styling to buttons. In most cases, you only need to pass the $button-color value for your buttons to look great
@mixin create_button(
    $button-color: null,
    $hover-color: $button-color,
    $hover-perc-amount: $ui-hover-function-amount
  ) {
  background-color: $button-color;
  border-color: $button-color;
  color: choose-contrast-color($button-color,$button-text-color-light,$button-text-color-dark);
  &:hover, &:focus, &:active {
    @if $button-color == $hover-color {
      background-color: call($ui-hover-function, $hover-color, $hover-perc-amount );
      border-color: call($ui-hover-function, $hover-color, $hover-perc-amount );
    }
    @else {
      background-color: $hover-color;
      border-color: $hover-color;
    }
    color: choose-contrast-color($hover-color,$button-text-color-light,$button-text-color-dark);
  }
  &:focus {
    // TODO:Move to using scale instead https://sass-lang.com/documentation/modules/color#scale
    box-shadow: 0px 0px 1px 3px call($ui-hover-function, $hover-color, $ui-focus-highlight-amount );
  }
  &.button__outline {
    &:hover, &:focus, &:active {
      color: $button-color;
    }
  }
}

// Apply consistent styling to labels
@mixin create_label($label-color) {
  border-color: $label-color;
  background-color: $label-color;
  color: choose-contrast-color($label-color,$label-text-color-light,$label-text-color-dark);
  &.label__outline {
    color: $label-color;
  }
}

// Allows us to use #{headings(1,6)} to apply css to all headings
@function headings($from:1, $to:6) {
  @if $from == $to {
      @return 'h#{$from}';
  } @else {
      @return 'h#{$from},' + headings($from+1, $to);
  }
}

// Center a block level element without worrying about top and bottom margins
@mixin center-block {
  margin: {
      left: auto;
      right: auto;
  }
}

// DRY mixin for Pseudo elements. Pass optional args or leave as default
@mixin pseudo($content: '', $display: block, $pos: absolute){
  content: $content;
  display: $display;
  position: $pos;
}

// Do Not Print
@mixin do-not-print {
  @media print {
    display: none;
  }
}

/**
 * Calculate the luminance for a color.
 * See https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @link https://medium.com/dev-channel/using-sass-to-automatically-pick-text-colors-4ba7645d2796
 */
 @function luminance($color) {
  $red: nth($linear-channel-values, red($color) + 1);
  $green: nth($linear-channel-values, green($color) + 1);
  $blue: nth($linear-channel-values, blue($color) + 1);

  @return .2126 * $red + .7152 * $green + .0722 * $blue;
}

/**
 * Calculate the contrast ratio between two colors.
 * See https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @link https://medium.com/dev-channel/using-sass-to-automatically-pick-text-colors-4ba7645d2796
 */
@function contrast($back, $front) {
  $backLum: luminance($back) + .05;
  $foreLum: luminance($front) + .05;

  @return max($backLum, $foreLum) / min($backLum, $foreLum);
}

/**
 * Determine whether to use dark or light text on top of given color.
 */
@function choose-contrast-color($color, $light-color: $color-white, $dark-color: $color-text) {
  $lightContrast: contrast($color, $light-color);
  $darkContrast: contrast($color, $dark-color);

  @if ($lightContrast > $darkContrast) {
    @return $light-color;
  }
  @else {
    @return $dark-color;
  }
}
