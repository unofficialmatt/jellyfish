/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  USEFUL MIXINS AND FUNCTIONS
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

@import 'linear-channel-values';

// Convert px to em
@function em($pixels) {
    @return #{$pixels/16px}em;
}

// Get a value from deep inside a map. Arguments:
// $map - name of map
// $keys - name of keys to retrieve. This can work with an infinitely nested map
@function map-deep-get($map, $keys...) {
  @each $key in $keys {
    $map: map-get($map, $key);
    @if not $map {
      //@warn "`#{$key}` does not exist in the queried key."; // Redacted as this is not super useful, because we only have one key value and not the parent key
    }
  }
  @return $map;
}

// Returns a given number divided by 2
@function h($num) {
  @return $num/2;
}

// Returns the negative value of a given number
@function n($num) {
  @return -$num;
}

// Returns the negative and halved value of a given number
@function nh($num) {
  @return n(h($num));
}
@function hn($num) {
  @return n(h($num));
}

// Lighten a colour progressively, much better than lighten()
@function tint($color, $percentage) {
  @return mix($color, white, $percentage);
}

// Darken a colour progressively, much better than darken()
@function shade($color, $percentage) {
  @return mix($color, black, $percentage);
}

// Media queries check the breakpoint map to see if a given string exists, else they convert a given pixel value to em.
@mixin above($min) {
    $bp-min: $min;
    @if map-has-key($breakpoints, $min) {
        $bp-min: map-deep-get($breakpoints, $min, 'breakpoint');
    }
    @else if (str-index(#{$min}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$min}` does not exist in the breakpoint map. Compile stopping.";
    }
    @media (min-width: em($bp-min)) {
        @content;
    }
}
@mixin between($min, $max) {
    $bp-min: $min;
    @if map-has-key($breakpoints, $min) {
        $bp-min: map-deep-get($breakpoints, $min, 'breakpoint');
    }
    @else if (str-index(#{$min}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$min}` does not exist in the breakpoint map. Compile stopping.";
    }
    $bp-max: $max;
    @if map-has-key($breakpoints, $max) {
        $bp-max: map-deep-get($breakpoints, $max, 'breakpoint');
    }
    @else if (str-index(#{$max}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$max}` does not exist in the breakpoint map. Compile stopping.";
    }
    @media (min-width: em($bp-min)) and (max-width: em($bp-max - 1px)) {
        @content;
    }
}
@mixin below($max) {
    $bp-max: $max;
    @if map-has-key($breakpoints, $max) {
        $bp-max: map-deep-get($breakpoints, $max, 'breakpoint');
    }
    @else if (str-index(#{$max}, 'px')) {
      // Do nothing, move to next step
    }
    @else {
     @error "The specified breakpoint `#{$max}` does not exist in the breakpoint map. Compile stopping.";
    }
    @media (max-width: em($bp-max - 1px)) {
        @content;
    }
}

@mixin smooth($properties...) { // Global transition
    $result: (); // Create empty variable
    @each $property in $properties {
        // Loop through each argument and append to result variable
        $result: append($result, #{$property} $global-transition, comma);
    }
    transition: $result;
}

// Apply consistent styling to buttons. In most cases, you only need to pass the $button-color value for your buttons to look great
@mixin create_button(
    $button-color: null,
    $hover-color: $button-color,
    $hover-perc-amount: $ui-hover-function-amount
  ) {
  background-color: $button-color;
  border-color: $button-color;
  color: choose-contrast-color($button-color,$button-text-color-light,$button-text-color-dark);
  &:hover, &:focus {
    @if $button-color == $hover-color {
      $hover-color: call(get-function($ui-hover-function), $hover-color, $hover-perc-amount );
    }
    background-color: $hover-color;
    border-color: $hover-color;
    color: choose-contrast-color($hover-color,$button-text-color-light,$button-text-color-dark);
  }
  &:focus {
    box-shadow: 0px 0px 1px 3px call(get-function($ui-hover-function), $hover-color, $ui-focus-highlight-amount );
  }
  &.outline, &.ghost {
    color: $button-color;
    &:hover, &:focus {
      color: $hover-color;
    }
  }
}

// Apply consistent styling to labels
@mixin create_label($label-color) {
  border-color: $label-color;
  background-color: $label-color;
  color: choose-contrast-color($label-color,$label-text-color-light,$label-text-color-dark);
  &.outline {
    color: $label-color;
  }
}

// Apply consistent styling to callouts
@mixin create_callout($callout-color) {
  border-color: $callout-color;
  background-color: tint($callout-color, $callout-tint-perc);
  color: choose-contrast-color(tint($callout-color, $callout-tint-perc),$color-text,$color-white);
  a.callout-link {
    color: $callout-color;
    &:hover, &:focus {
      color: shade($callout-color, 80%)
    }
  }
}

// Allows us to use #{headings(1,6)} to apply css to all headings
@function headings($from:1, $to:6) {
  @if $from == $to {
      @return 'h#{$from}';
  } @else {
      @return 'h#{$from},' + headings($from+1, $to);
  }
}

// Center a block level element without worrying about top and bottom margins
@mixin center-block {
  margin: {
      left: auto;
      right: auto;
  }
}

// DRY mixin for Pseudo elements. Pass optional args or leave as default
@mixin pseudo($content: '', $display: block, $pos: absolute){
  content: $content;
  display: $display;
  position: $pos;
}

// Do Not Print
@mixin do-not-print {
  @media print {
    display: none;
  }
}

/**
 * Calculate the luminance for a color.
 * See https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @link https://medium.com/dev-channel/using-sass-to-automatically-pick-text-colors-4ba7645d2796
 */
 @function luminance($color) {
  $red: nth($linear-channel-values, red($color) + 1);
  $green: nth($linear-channel-values, green($color) + 1);
  $blue: nth($linear-channel-values, blue($color) + 1);

  @return .2126 * $red + .7152 * $green + .0722 * $blue;
}

/**
 * Calculate the contrast ratio between two colors.
 * See https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @link https://medium.com/dev-channel/using-sass-to-automatically-pick-text-colors-4ba7645d2796
 */
@function contrast($back, $front) {
  $backLum: luminance($back) + .05;
  $foreLum: luminance($front) + .05;

  @return max($backLum, $foreLum) / min($backLum, $foreLum);
}

/**
 * Determine whether to use dark or light text on top of given color.
 */
@function choose-contrast-color($color, $light-color: $color-white, $dark-color: $color-text) {
  $lightContrast: contrast($color, $light-color);
  $darkContrast: contrast($color, $dark-color);

  @if ($lightContrast > $darkContrast) {
    @return $light-color;
  }
  @else {
    @return $dark-color;
  }
}

//TODO: Add Image Replacement mixin https://getbootstrap.com/docs/4.0/utilities/image-replacement/
