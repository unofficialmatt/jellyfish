/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
  GRID
  Contains the logic that builds
  Jellyfish's customisable grid
  system.
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

// Calculate width of one column based on amount defined in settings
$one_col: (100% / $cols);

.jf-debug {
  &::before {
      // Displays current breakpoint before page
      content: "#{$base-col-name}";
      position: fixed;
      top: 0;
      left: 0;
      padding: 10px;
      z-index: 10000;
      background: white;
      font-size: 12px;
      color: #555555;
      font-family: $font-body;
      @each $point,
      $i in $breakpoints {
          @include above($point) {
              content: "#{$point}";
          }
      }
  }
  .col {
      box-shadow: 0 1px 3px 1px rgba(8,247,254, .7) !important;
  }
  .row {
      box-shadow: 0 1px 3px 1px rgba(245, 211, 0, .8) !important;
      background: repeating-linear-gradient( to right, rgba(220, 220, 220, 0.4), rgba(220, 220, 220, 0.4) $one-col, rgba(245, 245, 245, 0.8) $one-col, rgba(245, 245, 245, 0.8) $one-col*2) !important;
      background-origin: content-box;
      .row {
          background: none !important; // Removes from nested rows
      }
  }
}
.container {
    margin: 0 auto;
    width: 100%;
    padding: 0 $base-container-gutter;
    .container {
      width: 100%;
      padding: 0 !important;
    }
}
.row {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    // Add negative margin to all rows, equal to half the col gutter - keeps things neatly aligned
    margin-left: -.5*$base-col-gutter;
    margin-right: -.5*$base-col-gutter;
}
.col {
    width: 100%;
    position: relative;
    // give our cols l-r margin equal to half col gutter
    padding-left: .5*$base-col-gutter;
    padding-right: .5*$base-col-gutter;
}
.col-auto {
  flex: 0 0 auto !important;
  width: auto;
  max-width: none !important;
}

// Remove column padding on collapsed rows
.row.collapse {
  margin-left: 0;
  margin-right: 0;
  & > .col {
    padding-left: 0 !important;
    padding-right: 0 !important;
  }
}
// Iterate for our smallest defined column class ($base-col-name)
@for $i from 1 through ($cols) {
    .col.#{$base-col-name}-#{$i} {
        max-width: ($one_col * $i);
        flex: 0 0 ($one_col * $i); // Define flex properties to fix the width of this col
    }
    @if $has_ordering {
        .order-#{$base-col-name}-#{$i} {
          order: $i;
        }
    }
    @if $has_offset {
        $offset: 100% - ($one_col * $i);
        .offset-#{$base-col-name}-#{$cols - $i} {
            margin-left: $offset;
        }
    }
}
$loop_count: 1;
@each $point,
$i in $breakpoints {

    // If we're not on the first loop through, set up classes that only affect this breakpoint size
    @if $loop_count != 1 {
      @include between($last, $point) {
        .hide-#{$last} {
          display: none !important;
        }
      }
    }
    // for each breakpoint defined...
    @include above($point) {

        // if a breakpoint is found, set media query min-width
        .container {
            // give our container a width/max width, and padding to border content
            width: bp-query($point, container-width);
            max-width: bp-query($point, container-max-width);
            padding-left: bp-query($point, container-gutter);
            padding-right: bp-query($point, container-gutter);
        }
        .row {
            // give our rows negative margin equal to half col gutter
            margin-left: -.5*(bp-query($point, col-gutter));
            margin-right: -.5*(bp-query($point, col-gutter));
        }
        .row.collapse-#{$point} {
            margin-left: 0;
            margin-right: 0;
            .col {
                padding-left: 0 !important;
                padding-right: 0 !important;
            }
        }
        .col {
            // give our cols l-r margin equal to half col gutter
            padding-left: .5*bp-query($point, col-gutter);
            padding-right: .5*bp-query($point, col-gutter);
            @if $loop_count == 1 {
            max-width: 100%;
            flex: 1 1 0px; // Ensures that if there are no breakpoint settings defined, columns fill available space on the row
            }
        }
        .col.#{$point}-auto {
          max-width: none;
          flex: 0 0 auto;
          width: auto;
        }
        .col.#{$point}-0 {
          max-width: 100%;
          flex: 1 1 0;
        }
        @for $i from 1 through ($cols) {
            .col.#{$point}-#{$i} {
                max-width: ($one_col * $i);
                flex: 0 0 ($one_col * $i); // Define flex properties to fix the width of this col
            }
            @if $has_ordering {
                .order-#{$point}-#{$i} {
                  order: $i;
                }
                .order-#{$point}-0 {
                  order: unset;
                }
            }
            @if $has_offset {
                $offset: 100% - ($one_col * $i);
                .offset-#{$point}-#{$cols - $i} {
                    margin-left: $offset;
                }
            }
        }
        .jf-debug {
            @if $has_ordering {
                [class*='order-#{$point}'] {
                  outline: 2px solid #fe53BB;
                }
                [class*='order-#{$point}-0'] {
                  outline: 0;
                }
            }
            @if $has_offset {
                [class*='offset-#{$point}'] {
                  outline: 2px solid #fe53BB;
                }
                [class*='offset-#{$point}-0'] {
                  outline: 0;
                }
            }
        }
        // Apply .hide class for the last item in the map
        @if $loop_count == length($breakpoints) {
          .hide-#{$point} {
            display: none !important;
          }
        }
    }
    .hide-below {
        &-#{$point} {
            @include below($point) {
                display: none !important;
            }
        }
    }
    .hide-above {
        &-#{$point} {
            @include above($point) {
                display: none !important;
            }
        }
    }
    $last: $point; // Store the current point to be used on the next loop
    $loop_count: $loop_count+1; // Increment loop count
}
